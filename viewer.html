<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PIXEL NFT Viewer – PIXELONKAS & SYKORA</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --panel: rgba(0,0,0,.18);
      --border: rgba(255,255,255,.12);
      --muted: rgba(255,255,255,.65);
      --accent:#00c4ff;
      --accentSoft: rgba(0,196,255,.14);
      --danger:#ffb4b4;
      --cardShadow: 0 18px 35px rgba(0,0,0,.5);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",sans-serif;
      background: radial-gradient(circle at top, #121623 0, #050608 52%);
      color:#f5f5f5;
      min-height:100vh;
    }
    .app{max-width:1100px;margin:0 auto;padding:24px 16px 48px}
    header{text-align:center;margin-bottom:10px}
    header h1{margin:8px 0 4px;font-size:2.1rem;letter-spacing:.12em;text-transform:uppercase}
    header p{margin:0;color:var(--muted);font-size:.95rem}

    .collection-switcher{
      display:inline-flex;
      padding:4px;
      background: rgba(10,12,18,.9);
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      margin:20px auto 6px;
      gap:6px;
    }
    .collection-button{
      border:none;background:transparent;color:rgba(255,255,255,.65);
      padding:8px 18px;border-radius:999px;font-size:.9rem;cursor:pointer;
      transition:background .2s,color .2s;
    }
    .collection-button.active{background: var(--accentSoft); color: var(--accent);}

    #metaBox{
      border:1px solid var(--border);
      border-radius:16px;
      padding:14px 16px;
      background: var(--panel);
      backdrop-filter: blur(10px);
      margin:18px auto 10px;
    }
    #metaRow{
      display:flex;gap:12px;flex-wrap:wrap;align-items:center;justify-content:space-between;
    }
    #metaTitle{font-weight:850;letter-spacing:.08em}
    .pill{
      padding:7px 12px;border-radius:999px;border:1px solid var(--border);
      background: rgba(5,7,11,.45);
      font-size:.9rem;
    }

    /* Bigger kaspa.com button */
    .mintPill{
      padding:10px 16px;
      border-radius:999px;
      border:1px solid rgba(0,196,255,.70);
      color: var(--accent);
      background: rgba(0,196,255,.08);
      font-weight: 800;
      font-size: 1rem;
      text-decoration:none;
      display:inline-flex;
      align-items:center;
      gap:10px;
      transition: background .15s, color .15s, transform .15s;
      white-space: nowrap;
    }
    .mintPill:hover{background: var(--accent); color:#020308; transform: translateY(-1px);}

    #statusLine{opacity:.75;font-size:14px;margin:10px 0}
    #grid{
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap:16px;
    }
    .card{
      padding:12px;border-radius:16px;border:1px solid var(--border);
      background: rgba(0,0,0,.18);
      backdrop-filter: blur(10px);
      box-shadow: var(--cardShadow);
      transition: transform .15s ease-out, box-shadow .15s ease-out, border-color .15s;
      display:flex;flex-direction:column;gap:10px;
    }
    .card:hover{transform: translateY(-3px); box-shadow:0 24px 40px rgba(0,0,0,.7); border-color: rgba(0,196,255,.22);}
    .thumb{
      width:100%;
      aspect-ratio: 1/1;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background:#000;
      overflow:hidden;
      display:flex;align-items:center;justify-content:center;
      color:rgba(255,255,255,.7);
      font-size:12px;
      text-align:center;
      padding:8px;
      cursor: zoom-in;
    }
    .thumb img{width:100%;height:100%;object-fit:cover;display:block}
    .row{display:flex;justify-content:space-between;gap:10px;align-items:center}
    .id{font-weight:850}
    .badge{
      padding:4px 10px;border-radius:999px;
      background: rgba(80,200,120,.16);
      border: 1px solid rgba(80,200,120,.28);
      font-size:12px;
    }
    .titleLine{font-weight:650;font-size:13px;opacity:.92;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .metaLine{opacity:.70;font-size:12px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}

    #loadMoreWrap{display:flex;justify-content:center;margin:18px 0 0}
    #loadMoreBtn{
      display:none;
      padding:10px 14px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:inherit;
      cursor:pointer;
    }
    .errBox{
      grid-column:1/-1;
      padding:14px;
      border-radius:14px;
      border:1px solid rgba(255,180,180,.35);
      color: var(--danger);
      background: rgba(255,180,180,.06);
      opacity:.95;
    }

    /* Lightbox */
    #lightbox{
      position: fixed; inset: 0;
      display: none;
      align-items: center; justify-content: center;
      padding: 18px;
      background: rgba(0,0,0,.72);
      z-index: 9999;
    }
    #lightbox.open{ display:flex; }
    .lbPanel{
      width: min(1100px, 96vw);
      max-height: 92vh;
      overflow: auto;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(10,12,18,.92);
      box-shadow: 0 30px 80px rgba(0,0,0,.75);
      backdrop-filter: blur(10px);
    }
    .lbTop{
      display:flex; justify-content: space-between; align-items:center;
      gap:12px; padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      position: sticky; top: 0;
      background: rgba(10,12,18,.92);
    }
    .lbTitle{display:flex; flex-direction:column; gap:2px;}
    .lbTitle b{letter-spacing:.06em}
    .lbBody{
      display:grid; grid-template-columns: 1.2fr .8fr;
      gap: 14px; padding: 14px;
    }
    .lbImgWrap{
      border-radius: 14px; overflow:hidden;
      border:1px solid rgba(255,255,255,.12);
      background:#000;
      display:flex; align-items:center; justify-content:center;
      min-height: 320px;
    }
    .lbImgWrap img{
      width:100%;
      height:auto;
      max-height: 75vh;
      object-fit: contain;
      display:block;
      cursor: zoom-out;
    }
    .lbSide{
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      padding: 12px;
      overflow:auto;
    }
    .kv{margin:0 0 10px}
    .kv .k{opacity:.7;font-size:12px;margin-bottom:4px}
    .kv .v{font-size:14px;word-break:break-word}
    .attrs{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px;}
    .chip{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);
      border-radius:999px;
      padding:6px 10px;
      font-size:12px;
      opacity:.95;
    }
    .btnSmall{
      font-size:.9rem;
      text-decoration:none;
      padding:8px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      color: rgba(255,255,255,.85);
      background: rgba(255,255,255,.06);
      display:inline-flex;
      gap:8px;
      align-items:center;
      cursor:pointer;
      user-select:none;
    }
    .btnSmall:hover{background: rgba(255,255,255,.12); color:#fff;}
    @media (max-width: 860px){
      .lbBody{grid-template-columns: 1fr;}
      .lbImgWrap{min-height: 240px;}
    }
  </style>
</head>
<body>
<div class="app">
  <header>
    <h1>PIXEL ON KASPA</h1>
    <p>Audio-visual art generated by sound and inscribed on the Kaspa blockDAG.</p>

    <div class="collection-switcher">
      <button class="collection-button active" data-collection="PIXELONKAS">PIXELONKAS</button>
      <button class="collection-button" data-collection="SYKORA">SYKORA</button>
    </div>
  </header>

  <section id="metaBox">
    <div id="metaRow">
      <div>
        <div id="metaTitle">—</div>
      </div>
      <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end;align-items:center;">
        <div id="metaMinted" class="pill">Minted: —</div>
        <div id="metaMax" class="pill">Max: —</div>
        <a id="mintBtn" class="mintPill" href="#" target="_blank" rel="noreferrer">Mint on kaspa.com</a>
      </div>
    </div>
  </section>

  <div id="statusLine">Ready.</div>

  <section>
    <div id="grid"></div>
    <div id="loadMoreWrap">
      <button id="loadMoreBtn">Load more</button>
    </div>
  </section>
</div>

<!-- Lightbox -->
<div id="lightbox" aria-hidden="true">
  <div class="lbPanel" role="dialog" aria-modal="true">
    <div class="lbTop">
      <div class="lbTitle">
        <b id="lbHeading">—</b>
        <span id="lbSub" style="opacity:.7;font-size:12px">—</span>
      </div>
      <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end">
        <a id="lbMint" class="mintPill" href="#" target="_blank" rel="noreferrer">Mint on kaspa.com</a>
        <a id="lbOpenImg" class="btnSmall" href="#" target="_blank" rel="noreferrer">Open image</a>
        <button id="lbFs" class="btnSmall" type="button">Full screen</button>
        <button id="lbClose" class="btnSmall" type="button">Close</button>
      </div>
    </div>
    <div class="lbBody">
      <div class="lbImgWrap" id="lbImgWrap"></div>
      <div class="lbSide" id="lbSide"></div>
    </div>
  </div>
</div>

<script>
(() => {
  const API_BASE = "https://mainnet.krc721.stream/api/v1/krc721/mainnet";

  const IPFS_GATEWAYS = [
    "https://dweb.link/ipfs/",
    "https://ipfs.io/ipfs/",
    "https://cloudflare-ipfs.com/ipfs/",
  ];

  const PAGE_SIZE = 60;
  const META_CONCURRENCY = 8;

  // krc721.stream /ranges/{tick} returns AVAILABLE (unminted) ranges as string.
  // We need max/idMin + buri for metadata.
  const COLLECTIONS = {
    PIXELONKAS: {
      buri: "ipfs://bafybeih2phpjzxfrszsscpmxdr44kliaddto3sicsdh44kgx7b3f43fdvm",
      max: 342,
      idMin: 2
    },
    SYKORA: {
      buri: "ipfs://bafybeifema4upmzu7c4iipvxdagctirxf46g3htmsin6l66zm77dibfhaq",
      max: 2518,
      idMin: 1
    }
  };

  function kaspaCollectionUrl(ticker){
    return `https://kaspa.com/nft/collections/${encodeURIComponent(String(ticker))}`;
  }

  const qs = (s)=>document.querySelector(s);
  const qsa = (s)=>Array.from(document.querySelectorAll(s));
  const gridEl = ()=>qs("#grid");

  function setStatus(html){ qs("#statusLine").innerHTML = html; }
  function setText(id, t){ const el=document.getElementById(id); if(el) el.textContent=t; }
  function showLoadMore(show){ qs("#loadMoreBtn").style.display = show ? "inline-flex" : "none"; }
  function renderError(msg){ gridEl().innerHTML = `<div class="errBox">${msg}</div>`; }

  function ipfsPath(ipfsUrl){
    if(!ipfsUrl) return "";
    if(ipfsUrl.startsWith("ipfs://")) return ipfsUrl.slice("ipfs://".length);
    const m = ipfsUrl.match(/\/ipfs\/(.+)$/);
    return m ? m[1] : "";
  }

  async function fetchJson(url, signal){
    const r = await fetch(url, { cache:"no-store", signal });
    if(!r.ok) throw new Error(`${url} HTTP ${r.status}`);
    return r.json();
  }

  function unwrapResult(x){
    if(x && typeof x === "object" && "result" in x) return x.result;
    return x;
  }

  // IMPORTANT: tries multiple candidate paths; each path tries multiple gateways
  async function fetchJsonFromGateways(paths, signal){
    let lastErr = null;
    for(const p of paths){
      for(const gw of IPFS_GATEWAYS){
        const url = gw + p;
        try{
          const r = await fetch(url, { cache:"no-store", signal, redirect:"follow" });
          if(!r.ok) throw new Error(`HTTP ${r.status}`);
          return { json: await r.json(), url };
        }catch(e){
          lastErr = e;
        }
      }
    }
    throw lastErr || new Error("IPFS fetch failed");
  }

  function firstTruthy(...vals){ for(const v of vals){ if(v) return v; } return ""; }

  function extractImageFromMeta(meta){
    const raw = firstTruthy(
      meta?.image,
      meta?.image_url,
      meta?.properties?.image,
      meta?.data?.image,
      meta?.content?.image,
      meta?.content?.url
    );
    if(!raw) return { primary:"", ipfs:null };
    if(raw.startsWith("ipfs://")){
      const p = ipfsPath(raw);
      return { primary: IPFS_GATEWAYS[0] + p, ipfs: p };
    }
    return { primary: raw, ipfs: null };
  }

  function availableCountFromRangesString(s){
    if(typeof s !== "string" || !s.trim()) return 0;
    const nums = s.split(",").map(x => Number(x.trim())).filter(Number.isFinite);
    let count = 0;
    for(let i=1;i<nums.length;i+=2) count += nums[i];
    return count;
  }

  function availableSetFromRangesString(s){
    const nums = s.split(",").map(x => Number(x.trim())).filter(Number.isFinite);
    const set = new Set();
    for(let i=0;i<nums.length-1;i+=2){
      const start = nums[i], len = nums[i+1];
      for(let j=0;j<len;j++) set.add(start + j);
    }
    return set;
  }

  function mintedIdsFromAvailableRanges({ idMin, max, rangesString }){
    const avail = availableSetFromRangesString(rangesString);
    const out = [];
    for(let id=idMin; id<=max; id++){
      if(!avail.has(id)) out.push(id);
    }
    return out;
  }

  function escapeHtml(str){
    return String(str)
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");
  }

  // ✅ Try /31.json, /31, /31/index.json + common subfolders
  function metaCandidatePaths(buri, tick, tokenId){
    const folder = ipfsPath(buri).replace(/\/+$/,"");
    const t = String(tick);

    return [
      `${folder}/${tokenId}.json`,
      `${folder}/${tokenId}`,
      `${folder}/${tokenId}/index.json`,

      `${folder}/metadata/${tokenId}.json`,
      `${folder}/metadata/${tokenId}`,
      `${folder}/metadata/${tokenId}/index.json`,

      `${folder}/meta/${tokenId}.json`,
      `${folder}/meta/${tokenId}`,
      `${folder}/meta/${tokenId}/index.json`,

      `${folder}/${t}/${tokenId}`,
      `${folder}/${t}/${tokenId}/index.json`,
      `${folder}/${t.toLowerCase()}/${tokenId}`,
      `${folder}/${t.toLowerCase()}/${tokenId}/index.json`
    ];
  }

  async function fetchRangesMeta(tick, signal){
    const raw = await fetchJson(`${API_BASE}/ranges/${encodeURIComponent(tick)}`, signal);
    const res = unwrapResult(raw);

    // Most common: ranges string
    if(typeof res === "string"){
      return { tick, rangesString: res };
    }

    // Sometimes: object or array. Try to find string inside.
    if(res && typeof res === "object"){
      if(typeof res.ranges === "string") return { tick: res.tick || tick, rangesString: res.ranges };
      if(Array.isArray(res)){
        const found = res.find(x => String(x?.tick).toUpperCase() === String(tick).toUpperCase());
        if(found && typeof found.ranges === "string") return { tick: found.tick || tick, rangesString: found.ranges };
      }
    }

    return { tick, rangesString: null };
  }

  // Lightbox
  const lb = {
    root: qs("#lightbox"),
    imgWrap: qs("#lbImgWrap"),
    side: qs("#lbSide"),
    heading: qs("#lbHeading"),
    sub: qs("#lbSub"),
    closeBtn: qs("#lbClose"),
    openImg: qs("#lbOpenImg"),
    mint: qs("#lbMint"),
    fsBtn: qs("#lbFs")
  };

  function requestFs(el){
    if(!el) return;
    const any = el;
    const fn = any.requestFullscreen || any.webkitRequestFullscreen || any.mozRequestFullScreen || any.msRequestFullscreen;
    if(fn) fn.call(any);
  }

  function openLightbox({ tick, tokenId, meta, imgUrl, imgIpfs, mintUrl }){
    lb.heading.textContent = `${tick} #${tokenId}`;
    lb.sub.textContent = meta?.name ? meta.name : "";
    lb.mint.href = mintUrl || "#";
    lb.openImg.href = imgUrl || "#";

    lb.imgWrap.innerHTML = imgUrl ? `<img id="lbImg" src="${imgUrl}" alt="">` : `<div style="opacity:.7;padding:18px">No image</div>`;
    const imgEl = lb.imgWrap.querySelector("img");

    if(imgEl && imgIpfs){
      let gwIndex = 0;
      imgEl.onerror = () => {
        gwIndex++;
        if(gwIndex < IPFS_GATEWAYS.length){
          imgEl.src = IPFS_GATEWAYS[gwIndex] + imgIpfs;
        }else{
          lb.imgWrap.textContent = "Image error";
        }
      };
      imgEl.onclick = () => closeLightbox();
    }

    lb.fsBtn.onclick = () => requestFs(imgEl || lb.imgWrap);

    const name = meta?.name || `#${tokenId}`;
    const desc = meta?.description || "";
    const attrs = Array.isArray(meta?.attributes) ? meta.attributes
      : (Array.isArray(meta?.properties?.attributes) ? meta.properties.attributes : []);

    lb.side.innerHTML = `
      <div class="kv">
        <div class="k">Name</div>
        <div class="v">${escapeHtml(name)}</div>
      </div>
      <div class="kv">
        <div class="k">Description</div>
        <div class="v">${desc ? escapeHtml(desc) : "<span style='opacity:.7'>—</span>"}</div>
      </div>
      <div class="kv">
        <div class="k">Attributes</div>
        <div class="v">
          ${attrs && attrs.length ? `
            <div class="attrs">
              ${attrs.slice(0, 64).map(a => {
                const t = a?.trait_type ?? a?.trait ?? a?.type ?? "Trait";
                const v = a?.value ?? a?.val ?? "";
                return `<span class="chip">${escapeHtml(String(t))}: <b>${escapeHtml(String(v))}</b></span>`;
              }).join("")}
            </div>
          ` : `<span style="opacity:.7">—</span>`}
        </div>
      </div>
    `;

    lb.root.classList.add("open");
    lb.root.setAttribute("aria-hidden", "false");
  }

  function closeLightbox(){
    lb.root.classList.remove("open");
    lb.root.setAttribute("aria-hidden", "true");
    lb.imgWrap.innerHTML = "";
    lb.side.innerHTML = "";
  }
  lb.closeBtn.addEventListener("click", closeLightbox);
  lb.root.addEventListener("click", (e)=>{ if(e.target===lb.root) closeLightbox(); });
  document.addEventListener("keydown",(e)=>{ if(e.key==="Escape" && lb.root.classList.contains("open")) closeLightbox(); });

  function cardSkeleton(tick, tokenId){
    return `
      <div class="card" data-tick="${tick}" data-tokenid="${tokenId}">
        <div class="thumb">Loading metadata…</div>
        <div class="row">
          <div class="id">#${tokenId}</div>
          <div class="badge">Minted</div>
        </div>
        <div class="titleLine" data-title>${tick} #${tokenId}</div>
        <div class="metaLine" data-desc>—</div>
      </div>
    `;
  }

  const metaCache = new Map();

  let currentTick = "PIXELONKAS";
  let currentBuri = null;
  let currentRangesString = null; // AVAILABLE / UNMINTED ranges string
  let mintedIds = [];             // computed minted IDs list
  let pageIndex = 0;
  let maxSupply = null;
  let abortCtrl = null;

  function setActiveButton(tick){
    qsa(".collection-button").forEach(btn => {
      btn.classList.toggle("active", btn.getAttribute("data-collection") === tick);
    });
  }

  async function loadCollection(tick){
    currentTick = tick;
    currentBuri = null;
    currentRangesString = null;
    mintedIds = [];
    pageIndex = 0;
    maxSupply = null;

    showLoadMore(false);
    gridEl().innerHTML = "";

    if(abortCtrl) abortCtrl.abort();
    abortCtrl = new AbortController();

    setText("metaTitle", tick);
    qs("#mintBtn").href = kaspaCollectionUrl(tick);

    setText("metaMinted", "Minted: —");
    setText("metaMax", "Max: —");
    setStatus(`Loading <b>${tick}</b>…`);

    const cfg = COLLECTIONS[tick];
    if(!cfg){
      renderError(`Missing config for <b>${tick}</b> in COLLECTIONS.`);
      setStatus(`Missing config.`);
      return;
    }

    try{
      const meta = await fetchRangesMeta(tick, abortCtrl.signal);
      currentRangesString = meta.rangesString || null;

      currentBuri = cfg.buri || null;
      maxSupply = cfg.max;
      const idMin = cfg.idMin;

      if(!currentRangesString){
        renderError(`Missing <b>ranges</b> for <b>${tick}</b> from krc721.stream.`);
        setStatus(`Missing ranges.`);
        return;
      }
      if(!currentBuri){
        renderError(`Missing <b>buri</b> for <b>${tick}</b>.`);
        setStatus(`Missing buri.`);
        return;
      }
      if(!Number.isFinite(maxSupply) || !Number.isFinite(idMin)){
        renderError(`Missing <b>max</b> or <b>idMin</b> for <b>${tick}</b> in COLLECTIONS.`);
        setStatus(`Missing max/idMin.`);
        return;
      }

      // rangesString = AVAILABLE (unminted) IDs
      const availableCount = availableCountFromRangesString(currentRangesString);
      const totalSupply = (maxSupply - idMin + 1);
      const mintedCount = Math.max(0, totalSupply - availableCount);

      // build minted IDs list (correct grid)
      mintedIds = mintedIdsFromAvailableRanges({ idMin, max: maxSupply, rangesString: currentRangesString });

      setText("metaMinted", `Minted: ${mintedCount}`);
      setText("metaMax", `Max: ${maxSupply}`);

      await renderNextPage();

    }catch(e){
      renderError(`Failed to load <b>${tick}</b>.<br/><code>${escapeHtml(String(e.message || e))}</code>`);
      setStatus(`Error.`);
      console.error(e);
    }
  }

  async function renderNextPage(){
    const tick = currentTick;
    const buri = currentBuri;
    if(!tick || !buri) return;

    const ids = mintedIds.slice(pageIndex, pageIndex + PAGE_SIZE);

    if(ids.length === 0){
      showLoadMore(false);
      setStatus(`No more items.`);
      return;
    }

    gridEl().insertAdjacentHTML("beforeend", ids.map(id => cardSkeleton(tick, id)).join(""));
    setStatus(`Loading metadata (${ids.length} items)…`);

    let idx = 0;
    const cards = Array.from(document.querySelectorAll(`.card[data-tick="${tick}"]`)).slice(-ids.length);

    async function worker(){
      while(idx < cards.length){
        const card = cards[idx++];
        const tokenId = Number(card.getAttribute("data-tokenid"));
        const cacheKey = `${tick}:${tokenId}`;

        const thumb = card.querySelector(".thumb");
        const titleEl = card.querySelector("[data-title]");
        const descEl = card.querySelector("[data-desc]");

        try{
          let meta = metaCache.get(cacheKey);
          if(!meta){
            const paths = metaCandidatePaths(buri, tick, tokenId);
            const { json } = await fetchJsonFromGateways(paths, abortCtrl.signal);
            meta = json;
            metaCache.set(cacheKey, meta);
          }

          const name = meta?.name || `${tick} #${tokenId}`;
          const desc = meta?.description || "";

          if(titleEl) titleEl.textContent = name;
          if(descEl) descEl.textContent = desc || "—";

          const { primary, ipfs } = extractImageFromMeta(meta);

          if(primary && thumb){
            thumb.innerHTML = `<img src="${primary}" alt="" loading="lazy">`;
            const imgEl = thumb.querySelector("img");
            if(imgEl && ipfs){
              let gwIndex = 0;
              imgEl.onerror = () => {
                gwIndex++;
                if(gwIndex < IPFS_GATEWAYS.length){
                  imgEl.src = IPFS_GATEWAYS[gwIndex] + ipfs;
                }else{
                  thumb.textContent = "Image error";
                }
              };
            }

            thumb.onclick = () => {
              const mintUrl = kaspaCollectionUrl(tick);
              openLightbox({ tick, tokenId, meta, imgUrl: primary, imgIpfs: ipfs, mintUrl });
            };
          }else{
            if(thumb) thumb.textContent = "No image in JSON";
          }

        }catch(e){
          if(thumb) thumb.textContent = "Meta error";
          if(descEl) descEl.textContent = "—";
        }
      }
    }

    await Promise.all(Array.from({length: META_CONCURRENCY}, worker));

    pageIndex += ids.length;

    if(pageIndex >= mintedIds.length){
      showLoadMore(false);
    }else{
      showLoadMore(true);
    }
    setStatus(`Ready. Loaded ${pageIndex} items.`);
  }

  qsa(".collection-button").forEach(btn => {
    btn.addEventListener("click", () => {
      const tick = btn.getAttribute("data-collection");
      setActiveButton(tick);
      loadCollection(tick);
    });
  });

  qs("#loadMoreBtn").addEventListener("click", () => renderNextPage());

  // Default
  loadCollection("PIXELONKAS");
})();
</script>
</body>
</html>
