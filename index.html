<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PIXELONKASPA</title>

<style>
html{scroll-behavior:smooth}

:root{
  --bg1:#121623;
  --bg2:#050608;
  --panel:rgba(0,0,0,.18);
  --border:rgba(255,255,255,.12);
  --muted:rgba(255,255,255,.70);
  --accent:#00c4ff;
  --shadow:0 18px 35px rgba(0,0,0,.5);
}
*{box-sizing:border-box}
body{
  margin:0;
  font-family:system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",sans-serif;
  background:radial-gradient(circle at top,var(--bg1) 0,var(--bg2) 52%);
  color:#f5f5f5;
}
a{text-decoration:none;color:inherit}
.wrap{max-width:1100px;margin:0 auto;padding:18px 16px 60px}

/* Top bar */
.topbar{
  position:sticky;top:12px;z-index:1000;margin-bottom:26px;
  display:flex;justify-content:space-between;align-items:center;
  padding:12px 14px;border-radius:16px;
  border:1px solid var(--border);
  background:var(--panel);backdrop-filter:blur(10px);
  box-shadow:var(--shadow);
}
.brand{
  font-weight:900;
  letter-spacing:.12em;
  text-transform:uppercase;
}
.nav{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end}

/* Buttons */
.btn{
  padding:9px 14px;border-radius:999px;
  border:1px solid rgba(255,255,255,.16);
  background:rgba(255,255,255,.06);
  font-weight:700;font-size:14px;
  transition:.15s;
  display:inline-flex;align-items:center;gap:8px;
}
.btn:hover{background:rgba(255,255,255,.12);transform:translateY(-1px)}
.btnPrimary{
  border-color:rgba(0,196,255,.7);
  color:var(--accent);
  background:rgba(0,196,255,.08);
}
.btnPrimary:hover{background:var(--accent);color:#020308}
.btnGhost{opacity:.9}

/* Hero */
.hero{
  text-align:center;
  margin:44px 0 28px;
}
.hero h1{
  margin:0;
  font-size:56px;
  letter-spacing:.28em;           /* ✅ větší mezery */
  text-transform:uppercase;
  line-height:1.05;
}
.sub{
  margin:14px auto 0;
  max-width:68ch;
  opacity:.82;
  line-height:1.55;
  font-size:15px;                /* ✅ víc “tight” než předtím */
}
.sub span{display:block}

/* Cards */
.cards{
  display:grid;
  grid-template-columns:repeat(2,1fr);
  gap:20px;
}
.card{
  border:1px solid var(--border);
  border-radius:22px;
  background:rgba(0,0,0,.18);
  backdrop-filter:blur(10px);
  box-shadow:var(--shadow);
  overflow:hidden;
  transition:.15s;
  position:relative;
}
.card:hover{
  transform:translateY(-4px);
  border-color:rgba(0,196,255,.25);
}
.cardImg{
  aspect-ratio:16/10;
  background:#000;
  overflow:hidden;
  position:relative;
}
.cardImg img{
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
}
.pill{
  position:absolute;
  top:10px;
  padding:6px 10px;
  border-radius:999px;
  font-size:12px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(0,0,0,.22);
  backdrop-filter:blur(10px);
  opacity:.92;
}
.pillTag{
  left:10px;
  border-color:rgba(0,196,255,.35);
  background:rgba(0,196,255,.10);
  color:var(--accent);
  font-weight:900;
  letter-spacing:.08em;
  text-transform:uppercase;
}
.pillMint{right:10px}

.cardBody{padding:18px}
.cardBody h2{
  margin:0 0 6px;
  font-size:22px;
  letter-spacing:.12em;
  text-transform:uppercase;
}
.cardBody p{
  margin:0 0 14px;
  opacity:.80;
  line-height:1.55;
}
.cardActions{display:flex;gap:10px;flex-wrap:wrap}

/* Rewards section */
.section{
  margin-top:22px;
  border:1px solid var(--border);
  border-radius:22px;
  background:rgba(0,0,0,.14);
  backdrop-filter:blur(10px);
  box-shadow:var(--shadow);
  padding:18px;
}
.sectionTitle{
  margin:0 0 10px;
  letter-spacing:.14em;
  text-transform:uppercase;
  font-weight:900;
  opacity:.9;
}
.cols{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:18px;
}
.rewBox{
  border:1px solid rgba(255,255,255,.10);
  border-radius:18px;
  background:rgba(255,255,255,.04);
  padding:14px;
}
.rewBox h3{
  margin:0 0 10px;
  letter-spacing:.12em;
  text-transform:uppercase;
  font-size:14px;
  opacity:.9;
}
.rewList{margin:0;padding-left:16px;opacity:.82;line-height:1.6}
.rewList li{margin:6px 0}

/* Footer */
footer{
  margin-top:42px;
  opacity:.7;
  font-size:13px;
  display:flex;
  justify-content:space-between;
  flex-wrap:wrap;
  gap:12px;
}

@media(max-width:900px){
  .cards{grid-template-columns:1fr}
  .cols{grid-template-columns:1fr}
  .hero h1{font-size:40px;letter-spacing:.22em}
}
</style>
</head>

<body>
<div class="wrap">

<!-- TOP -->
<div class="topbar">
  <div class="brand">PIXELONKASPA</div>
  <div class="nav">
    <a class="btn btnPrimary" href="/viewer">Viewer</a>
    <a class="btn btnGhost" href="#rewards">Rewards</a>
    <a class="btn" href="https://kaspa.com/nft/collections/PIXELONKAS" target="_blank" rel="noreferrer">PIXELONKAS</a>
    <a class="btn" href="https://kaspa.com/nft/collections/SYKORA" target="_blank" rel="noreferrer">SYKORA</a>
    <a class="btn" href="https://x.com/PixelonKas" target="_blank" rel="noreferrer">X</a>
    <a class="btn" href="https://t.me/+Ro2t1MjZunIxM2M8" target="_blank" rel="noreferrer">TG</a>
  </div>
</div>

<!-- HERO -->
<section class="hero">
  <h1>PIXELONKASPA</h1>
  <p class="sub">
    <span>Sound-driven image generation inscribed on the Kaspa blockDAG.</span>
    <span>Two collections. Minted pieces only.</span>
  </p>
</section>

<!-- COLLECTION CARDS -->
<section class="cards">

  <!-- PIXELONKAS -->
  <div class="card">
    <div class="cardImg" id="coverPIXELONKAS">
      <span class="pill pillTag">PIXELONKAS</span>
      <span class="pill pillMint" id="mintPillPIXELONKAS">Last mint: —</span>
    </div>
    <div class="cardBody">
      <h2>PIXELONKAS</h2>
      <p>Genesis collection of 342 sound-generated NFTs. Rarity-based $PIXEL rewards.</p>
      <div class="cardActions">
        <a class="btn btnPrimary" href="/viewer?c=PIXELONKAS">Open Viewer</a>
        <a class="btn" href="https://kaspa.com/nft/collections/PIXELONKAS" target="_blank" rel="noreferrer">Mint on kaspa.com</a>
      </div>
    </div>
  </div>

  <!-- SYKORA -->
  <div class="card">
    <div class="cardImg" id="coverSYKORA">
      <span class="pill pillTag">SYKORA</span>
      <span class="pill pillMint" id="mintPillSYKORA">Last mint: —</span>
    </div>
    <div class="cardBody">
      <h2>SYKORA</h2>
      <p>Expanded collection of 2,518 NFTs with instant $PIXEL perks for selected rarities.</p>
      <div class="cardActions">
        <a class="btn btnPrimary" href="/viewer?c=SYKORA">Open Viewer</a>
        <a class="btn" href="https://kaspa.com/nft/collections/SYKORA" target="_blank" rel="noreferrer">Mint on kaspa.com</a>
      </div>
    </div>
  </div>

</section>

<!-- REWARDS -->
<section id="rewards" class="section">
  <div class="sectionTitle">Rewards</div>

  <div class="cols">
    <div class="rewBox">
      <h3>PIXELONKAS</h3>
      <ul class="rewList">
        <li>Mint price: 287 KAS</li>
        <li>Total rewards: 10B $PIXEL</li>
        <li>Top: Super Broken (1) → 1B $PIXEL</li>
        <li>Broken (24) → 100M $PIXEL</li>
        <li>Grey (10) → 80M · Orange (15) → 50M · Yellow (17) → 30M</li>
        <li>Pink (22) → 26M · Red (25) → 24M · Purple (27) → 22M</li>
        <li>White (28) → 20M · Green (46) → 15M · Black (63) → 12M · Blue (64) → 12M</li>
      </ul>
    </div>

    <div class="rewBox">
      <h3>SYKORA</h3>
      <ul class="rewList">
        <li>Only 2,518 NFTs — rarities are limited</li>
        <li>Ice (23) → 100M $PIXEL + future airdrop perks</li>
        <li>Black style (9) → 80M $PIXEL + 1 bonus SYKORA NFT</li>
        <li>Pink style (58) → 40M $PIXEL</li>
        <li>Own 5 different styles → unlock a special bonus</li>
      </ul>
    </div>
  </div>
</section>

<footer>
  <div>© Pixel on Kaspa</div>
  <div>
    <a href="/viewer">Viewer</a> ·
    <a href="https://x.com/PixelonKas" target="_blank" rel="noreferrer">X</a> ·
    <a href="https://t.me/+Ro2t1MjZunIxM2M8" target="_blank" rel="noreferrer">TG</a>
  </div>
</footer>

</div>

<script>
(() => {
  // Primary “truth” for minted-by-date should come from Kaspa API (recent mints).
  // Fallback: derive last minted by scanning ranges (works but not “by date”).
  const KRC721_STREAM = "https://mainnet.krc721.stream/api/v1/krc721/mainnet";

  // Try Kaspa API variants (we don't break UI if endpoint differs).
  const KASPA_API_TRIES = [
    // Variant A (common pattern): /api/krc721/mint?ticker=...&limit=1
    (tick) => `https://api.kaspa.com/api/krc721/mint?ticker=${encodeURIComponent(tick)}&limit=1`,
    // Variant B: /api/krc721/mint?collection=...&page=1&limit=1
    (tick) => `https://api.kaspa.com/api/krc721/mint?collection=${encodeURIComponent(tick)}&page=1&limit=1`,
    // Variant C: /api/krc721/mint?ticker=... (server may default limit)
    (tick) => `https://api.kaspa.com/api/krc721/mint?ticker=${encodeURIComponent(tick)}`
  ];

  const IPFS_GATEWAYS = [
    "https://dweb.link/ipfs/",
    "https://ipfs.io/ipfs/",
    "https://cloudflare-ipfs.com/ipfs/"
  ];

  const COL = {
    PIXELONKAS: { buri:"ipfs://bafybeih2phpjzxfrszsscpmxdr44kliaddto3sicsdh44kgx7b3f43fdvm", max:342 },
    SYKORA: { buri:"ipfs://bafybeifema4upmzu7c4iipvxdagctirxf46g3htmsin6l66zm77dibfhaq", max:2518 }
  };

  const ipfsPath = (u)=>String(u||"").replace("ipfs://","");
  const qs = (s)=>document.querySelector(s);

  async function fetchJson(url){
    const r = await fetch(url, { cache:"no-store" });
    if(!r.ok) throw new Error(`HTTP ${r.status}`);
    return r.json();
  }

  function unwrap(x){
    return (x && typeof x==="object" && "result" in x) ? x.result : x;
  }

  function availableSetFromRangesString(s){
    const n = String(s).split(",").map(x=>Number(x.trim())).filter(Number.isFinite);
    const set = new Set();
    for(let i=0;i<n.length-1;i+=2){
      const start=n[i], len=n[i+1];
      for(let j=0;j<len;j++) set.add(start+j);
    }
    return set;
  }

  async function lastMintedFallbackByRanges(tick){
    const raw = await fetchJson(`${KRC721_STREAM}/ranges/${encodeURIComponent(tick)}`);
    const res = unwrap(raw);
    if(typeof res !== "string" || !res.trim()) return null;

    const max = COL[tick]?.max || 1;
    const avail = availableSetFromRangesString(res);

    // minted = not in avail
    for(let id=max; id>=1; id--){
      if(!avail.has(id)) return id;
    }
    return null;
  }

  // Try to get last mint by DATE from Kaspa API recent mints
  async function lastMintedByDateKaspaApi(tick){
    for(const makeUrl of KASPA_API_TRIES){
      const url = makeUrl(tick);
      try{
        const data = await fetchJson(url);

        // We accept multiple shapes:
        // { items:[{tokenId: "123"}] }
        // { result:[{tokenId:...}] }
        // [{tokenId:...}]
        const items =
          (Array.isArray(data) ? data :
          Array.isArray(data?.items) ? data.items :
          Array.isArray(data?.result) ? data.result :
          Array.isArray(data?.data) ? data.data : null);

        if(items && items.length){
          const it = items[0];

          // tokenId might be tokenId / id / token_id
          const tokenId = Number(it?.tokenId ?? it?.id ?? it?.token_id);
          if(Number.isFinite(tokenId) && tokenId > 0) return tokenId;
        }
      }catch(e){
        // try next variant
      }
    }
    return null;
  }

  function metaCandidatePaths(buri, tick, tokenId){
    const base = ipfsPath(buri).replace(/\/+$/,"");
    const t = String(tick);
    return [
      `${base}/${tokenId}.json`,
      `${base}/${tokenId}`,
      `${base}/${tokenId}/index.json`,
      `${base}/metadata/${tokenId}.json`,
      `${base}/metadata/${tokenId}`,
      `${base}/metadata/${tokenId}/index.json`,
      `${base}/${t}/${tokenId}`,
      `${base}/${t}/${tokenId}/index.json`,
      `${base}/${t.toLowerCase()}/${tokenId}`,
      `${base}/${t.toLowerCase()}/${tokenId}/index.json`
    ];
  }

  async function fetchMetaFromGateways(paths){
    for(const p of paths){
      for(const gw of IPFS_GATEWAYS){
        try{
          const r = await fetch(gw + p, { cache:"no-store", redirect:"follow" });
          if(!r.ok) continue;
          return r.json();
        }catch(e){}
      }
    }
    return null;
  }

  function extractImage(meta){
    const raw =
      meta?.image ||
      meta?.image_url ||
      meta?.properties?.image ||
      meta?.data?.image ||
      meta?.content?.image ||
      meta?.content?.url;

    if(!raw) return { url:"", ipfs:null };
    if(String(raw).startsWith("ipfs://")){
      const p = ipfsPath(raw);
      return { url: IPFS_GATEWAYS[0] + p, ipfs: p };
    }
    return { url:String(raw), ipfs:null };
  }

  async function loadCover(tick){
    const cfg = COL[tick];
    const box = qs("#cover"+tick);
    const pill = qs("#mintPill"+tick);
    if(!cfg || !box || !pill) return;

    // 1) try last minted by date (Kaspa API)
    let lastId = await lastMintedByDateKaspaApi(tick);

    // 2) fallback (ranges scan)
    if(!lastId) lastId = await lastMintedFallbackByRanges(tick);

    if(!lastId){
      pill.textContent = "Last mint: —";
      return;
    }
    pill.textContent = `Last mint: #${lastId}`;

    const meta = await fetchMetaFromGateways(metaCandidatePaths(cfg.buri, tick, lastId));
    const { url, ipfs } = extractImage(meta || {});
    if(!url){
      // Keep pills but no image
      box.insertAdjacentHTML("beforeend", `<div style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;opacity:.7">Cover unavailable</div>`);
      return;
    }

    box.insertAdjacentHTML("beforeend", `<img src="${url}" alt="${tick} #${lastId}" loading="lazy">`);

    // image fallback gateways if ipfs
    const img = box.querySelector("img");
    if(img && ipfs){
      let gw = 0;
      img.onerror = () => {
        gw++;
        if(gw < IPFS_GATEWAYS.length){
          img.src = IPFS_GATEWAYS[gw] + ipfs;
        }
      };
    }
  }

  loadCover("PIXELONKAS");
  loadCover("SYKORA");
})();
</script>
</body>
</html>
